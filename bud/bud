#!/usr/bin/env ruby
require "bundler/setup"
require "dry/cli"
require "active_support/core_ext/class/attribute"
require "yaml"
require "paint"
require "tty-command"

def header(message)
  puts "\n"
  puts Paint["######", :magenta]
  puts message
  puts Paint["######", :magenta]
  puts "\n"
end

def speak(message)
  puts "-> #{message}"
end

def gems
  YAML.load_file("gems.yml")["gems"].each do |gem, path|
    [gem, File.expand_path(path, Dir.pwd)]
  end.to_h
end

module Bud
  VERSION = "0.0.1"

  module CLI
    module Commands
      extend Dry::CLI::Registry

      class Version < Dry::CLI::Command
        desc "Print version"

        def call(*)
          puts VERSION
        end
      end

      class GenericCommand < Dry::CLI::Command
        class_attribute :command, default: "bundle"

        desc "Run #{command} version"

        def call(*)
          cmd = TTY::Command.new

          command = self.class.command
          gems.each do |gem, path|
            speak "Running `#{command}` in #{path}"

            cmd.run(command, chdir: path.to_s)
          end
        end
      end

      class Bundle < GenericCommand
      end

      class Yarn < GenericCommand
      end
      Yarn.command = "yarn"

      class Procfile < Dry::CLI::Command
        desc "Generate the main Procfile that runs the whole operation"

        def call(*)
          header "Generate common Procfile"

          contents = "web: bin/rails server -p 3030\n"
          regex = /(.*): (.*)/
          gems.each do |gem_name, gem_path|
            next unless File.exist?("#{gem_path}/Procfile.dev")

            proc_contents = File.open("#{gem_path}/Procfile.dev").readlines
            proc_contents.each do |line|
              parsed = line.match(regex)
              command_name = parsed[1]
              command = parsed[2]

              # When Running the general Prommy app we don't want to run any prommy app from each gem
              next if command_name == "web"

              contents << "#{gem_name}-#{command_name}: cd #{gem_path} && #{command}\n"
            end
          end

          File.write("Procfile", contents)
        end
      end




      class Bundles < Dry::CLI::Command
        desc "Print input"

        argument :input, desc: "Input to print"

        example [
          "             # Prints 'wuh?'",
          "hello, folks # Prints 'hello, folks'"
        ]

        def call(input: nil, **)
          if input.nil?
            puts "wuh?"
          else
            puts input
          end
        end
      end

      class Echo < Dry::CLI::Command
        desc "Print input"

        argument :input, desc: "Input to print"

        example [
          "             # Prints 'wuh?'",
          "hello, folks # Prints 'hello, folks'"
        ]

        def call(input: nil, **)
          if input.nil?
            puts "wuh?"
          else
            puts input
          end
        end
      end

      class Start < Dry::CLI::Command
        desc "Start Foo machinery"

        argument :root, required: true, desc: "Root directory"

        example [
          "path/to/root # Start Foo at root directory"
        ]

        def call(root:, **)
          puts "started - root: #{root}"
        end
      end

      class Stop < Dry::CLI::Command
        desc "Stop Foo machinery"

        option :graceful, type: :boolean, default: true, desc: "Graceful stop"

        def call(**options)
          puts "stopped - graceful: #{options.fetch(:graceful)}"
        end
      end

      class Exec < Dry::CLI::Command
        desc "Execute a task"

        argument :task, type: :string, required: true,  desc: "Task to be executed"
        argument :dirs, type: :array,  required: false, desc: "Optional directories"

        def call(task:, dirs: [], **)
          puts "exec - task: #{task}, dirs: #{dirs.inspect}"
        end
      end

      module Generate
        class Configuration < Dry::CLI::Command
          desc "Generate configuration"

          option :apps, type: :array, default: [], desc: "Generate configuration for specific apps"

          def call(apps:, **)
            puts "generated configuration for apps: #{apps.inspect}"
          end
        end

        class Test < Dry::CLI::Command
          desc "Generate tests"

          option :framework, default: "minitest", values: %w[minitest rspec]

          def call(framework:, **)
            puts "generated tests - framework: #{framework}"
          end
        end
      end

      register "version", Version, aliases: ["v", "-v", "--version"]
      register "echo",    Echo
      register "start",   Start
      register "stop",    Stop
      register "exec",    Exec

      register "yarn",    Yarn
      register "bundle",    Bundle
      register "procfile",    Procfile

      register "generate", aliases: ["g"] do |prefix|
        prefix.register "config", Generate::Configuration
        prefix.register "test",   Generate::Test
      end
    end
  end
end

Dry::CLI.new(Bud::CLI::Commands).call
